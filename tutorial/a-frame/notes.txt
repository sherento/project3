A-Frame notes

Register own primitive elements
e.g. a-box
using: AFRAME.registerPrimitive(name, definition).
name is a string and must contain a dash (i.e. 'a-foo').
definition is a JavaScript object defining these properties:
- default components: object specifying deafult components of the primitive.
The keys are the components names and values are components default data
i.e. {geometry: {primitive: 'box'}}
-mappings: object specifying mapping between HTML attribute name and component property names
whenever html attribute name is updated, primitive will update corresponding component property
The component property is defined using dot syntax:
${componentName}.${propertyName}
i.e. {depth: 'geometry.depth', height: 'geometry.height', width: 'geometry.width'}

for example:
var extendDeep = AFRAME.utils.extendDeep;
// The mesh mixin provides common material properties for creating mesh-based primitives.
// This makes the material component a default component and maps all the base material properties.
var meshMixin = AFRAME.primitives.getMeshMixin();
AFRAME.registerPrimitive('a-box', extendDeep({}, meshMixin, {
  // Preset default components. These components and component properties will be attached to the entity out-of-the-box.
  defaultComponents: {
    geometry: {primitive: 'box'}
  },
  // Defined mappings from HTML attributes to component properties (using dots as delimiters).
  // If we set `depth="5"` in HTML, then the primitive will automatically set `geometry="depth: 5"`.
  mappings: {
    depth: 'geometry.depth',
    height: 'geometry.height',
    width: 'geometry.width'
  }
}));

A-Frame is a three.js framework with an entity-component-system(ECS)
(Basic definition of ECS involves:)
-Entities: container objects into which components can be attached.
entities are the base of all objects in the scene
without components, entities neither do nor render anything, similar to empty divs
-Components: are reusable modules or data containers that can be attached to entities to provide appearance, behaviour and/or functionality
components are like plug-and-play for objects
all logic implemented through components
define different types of objects by mixing, matching, configuring components
-System: provides global scope, management and services for classes of components
often optional
can use them to separate logic and data
systems handle logic
components act as data containers

examples:
Some abstract examples of different types of entities built from composing together different components:

Box = Position + Geometry + Material
Light Bulb = Position + Light + Geometry + Material + Shadow
Sign = Position + Geometry + Material + Text
VR Controller = Position + Rotation + Input + Model + Grab + Gestures
Ball = Position + Velocity + Physics + Geometry + Material
Player = Position + Camera + Input + Avatar + Identity
As another abstract example, imagine we want to build a car entity by assembling components:

We can attach a material component that has properties such as “color” or “shininess” that affects the appearance of the car.
We can attach an engine component that has properties such as “horsepower” or “weight” that affects the functionality of the car.
We can attach a tire component that has properties such as “number of tires” or “steering angle” that affects the behavior of the car.
So we can create different types of cars by varying the properties of the material, engine, and tire component. The material, engine, and tire components don’t have to know about each other and can even be used in isolation for other cases. We could mix and match them to create even different types of vehicles:

To create a boat entity: remove the tire component.
To create a motorcycle entity: change tire component’s number of tires to 2, configure the engine component to be smaller.
To create an airplane entity: attach wing and jet components.

ECS in A-Frame
A-Frame has APIs that represents each piece of ECS:

Entities are represented by the <a-entity> element and prototype.
Components are represented by HTML attributes on <a-entity>‘s. Underneath, components are objects containing a schema, lifecycle handlers, and methods. Components are registered via the AFRAME.registerComponent (name, definition) API.
Systems are represented by <a-scene>‘s HTML attributes. System are similar to components in definition. Systems are registered via the AFRAME.registerSystem (name, definition) API.

syntax:

create <a-entity> and attache components as HTML attributes
i.e.
<a-entity ${componentName}="${propertyName1}: ${propertyValue1}; ${propertyName2}: ${propertyValue2}">
e.g.
<a-entity geometry="primitive: sphere; radius: 1.5"
          light="type: point; color: white; intensity: 2"
          material="color: white; shader: flat; src: glow.jpg"
          position="0 0 -5"></a-entity>

composition:
from here can attache more components to add additional appearance, behaviour or functionality
or update component values to configure the entity (either declaratively or through .setAttribute)

e.g multiple components for players hands in VR
plug in components into hand entity to provide behaviour
each component have no knowledge of each other but when combined defines complex entity
<a-entity
  tracked-controls  <!-- Hook into the Gamepad API for pose. -->
  vive-controls  <!-- Vive button mappings. -->
  oculus-touch-controls  <!-- Oculus button mappings. -->
  hand-controls  <!-- Appearance (model), gestures, and events. -->
  controller-cursor  <!-- Laser to interact with menus and UI. -->
  sphere-collider  <!-- Listen when hand is in contact with an object. -->
  grab  <!-- Provide ability to grab objects. -->
  throw <!-- Provide ability to throw objects. -->
  event-set="_event: grabstart; visible: false"  <!-- Hide hand when grabbing object. -->
  event-set="_event: grabend; visible: true"  <!-- Show hand when no longer grabbing object. -->
>

A-Frame components can do anything
create components to extend any feature
full access to javascript, three.js and web APIs
basic structure of writing an A-Frame component:
AFRAME.registerComponent('foo', {
  schema: {
    bar: {type: 'number'},
    baz: {type: 'string'}
  },
  init: function () {
    // Do something when component first attached.
  },
  update: function () {
    // Do something when component's data is updated.
  },
  remove: function () {
    // Do something the component or its entity is detached.
  },
  tick: function (time, timeDelta) {
    // Do something on every scene tick or frame.
  }
});

declarative ECS gives ability to write a JavaScript module and abstract it through HTML
once component registered, can plug module of code into entity via html attribute
e.g from above creating component foo, data contains bar and baz properties:
<a-entity foo="bar: 5; baz: bazValue"></a-entity>

Component-Based Development

for building VR applications:
place all application code within components( and systems)
ideal A-Frame codebase consists purely of modular, encapsulated and decoupled Components

when application is created solely with components, all parts of its codebase become reusable
e.g.
index.html
components/
  ball.js
  collidable.js
  grabbable.js
  enemy.js
  scoreboard.js
  throwable.js

if want to get one element, use .querySelector()
e.g. var sceneE1 = document.querySelector('a-scene');

if working within a component, already have reference to the scene element without needing to query
all entities have reference to their scene element
e.g.
AFRAME.registerComponent('foo', {
  init: function () {
    console.log(this.el.sceneEl);  // Reference to the scene element.
  }
});

if using id

var sceneEl = document.querySelector('a-scene');
console.log(sceneEl.querySelector('#redBox'));
// <a-box id="redBox" class="clickable" color="red"></a-box>




register component
AFRAME.registerComponent('hello-world', {
  init: function () {
    console.log('Hello, World!');
  }
});

then can use as:
<a-scene>
  <a-entity hello-world></a-entity>
</a-scene>

define properties with schema:
AFRAME.registerComponent('log', {
  schema: {
    message: {type: 'string', default: 'Hello, World!'}
  },
  // ...
});



AFRAME.registerComponent('log', {
  schema: {
    message: {type: 'string', default: 'Hello, World!'}
  },
  init: function () {
    console.log(this.data.message);
  }
});

then from html can attach component:
<a-scene>
  <a-entity log="message: Hello, Metaverse!"></a-entity>
</a-scene>


AFRAME.registerComponent('log', {
  schema: {
    event: {type: 'string', default: ''},
    message: {type: 'string', default: 'Hello, World!'}
  },
  init: function () {
    var self = this;
    this.eventHandlerFn = function () { console.log(self.data.message); };
  },
  update: function (oldData) {
    var data = this.data;
    var el = this.el;
    // `event` updated. Remove the previous event listener if it exists.
    if (oldData.event && data.event !== oldData.event) {
      el.removeEventListener(oldData.event, this.eventHandlerFn);
    }
    if (data.event) {
      el.addEventListener(data.event, this.eventHandlerFn);
    } else {
      console.log(data.message);
    }
  }
});















































.
